#include "PluginExporter.h"

juce::String PluginExporter::generatePluginCode(
    FrameworkType framework,
    const juce::OwnedArray<DraggableWidget>& widgets,
    const juce::String& pluginName,
    const juce::String& manufacturer)
{
    switch (framework)
    {
        case FrameworkType::JUCE:
            return generateJUCECode(widgets, pluginName);
        case FrameworkType::IPlug2:
            return generateIPlug2Code(widgets, pluginName);
        case FrameworkType::DPF:
            return generateDPFCode(widgets, pluginName);
        case FrameworkType::Elements:
            return generateElementsCode(widgets, pluginName);
        default:
            return "";
    }
}

// ============================================================================
// JUCE Plugin Generator
// ============================================================================
juce::String PluginExporter::generateJUCECode(
    const juce::OwnedArray<DraggableWidget>& widgets,
    const juce::String& pluginName)
{
    juce::String code;
    
    // Header
    code << "// " << pluginName << " - Generated by Visual GUI Builder\n\n";
    code << "#pragma once\n";
    code << "#include <JuceHeader.h>\n\n";
    
    // Processor class
    code << "class " << pluginName << "AudioProcessor : public juce::AudioProcessor\n";
    code << "{\n";
    code << "public:\n";
    code << "    " << pluginName << "AudioProcessor();\n";
    code << "    ~" << pluginName << "AudioProcessor() override;\n\n";
    code << "    void processBlock(juce::AudioBuffer<float>&, juce::MidiBuffer&) override;\n";
    code << "    // ... standard JUCE AudioProcessor methods\n\n";
    
    // Parameters
    code << "private:\n";
    code << "    juce::AudioProcessorValueTreeState parameters;\n";
    for (auto* widget : widgets)
    {
        if (widget->getWidgetType() == DraggableWidget::WidgetType::Knob ||
            widget->getWidgetType() == DraggableWidget::WidgetType::Slider)
        {
            code << "    std::atomic<float>* " << widget->getWidgetName().replaceCharacter(' ', '_') << "Param = nullptr;\n";
        }
    }
    code << "};\n\n";
    
    // Editor class
    code << "class " << pluginName << "AudioProcessorEditor : public juce::AudioProcessorEditor\n";
    code << "{\n";
    code << "public:\n";
    code << "    " << pluginName << "AudioProcessorEditor(" << pluginName << "AudioProcessor&);\n";
    code << "    ~" << pluginName << "AudioProcessorEditor() override;\n\n";
    code << "    void paint(juce::Graphics&) override;\n";
    code << "    void resized() override;\n\n";
    
    code << "private:\n";
    for (auto* widget : widgets)
    {
        code << widgetToJUCECode(widget);
    }
    code << "    " << pluginName << "AudioProcessor& audioProcessor;\n";
    code << "};\n";
    
    return code;
}

juce::String PluginExporter::widgetToJUCECode(const DraggableWidget* widget)
{
    juce::String code;
    juce::String varName = widget->getWidgetName().replaceCharacter(' ', '_');
    
    switch (widget->getWidgetType())
    {
        case DraggableWidget::WidgetType::Knob:
            code << "    juce::Slider " << varName << ";\n";
            code << "    juce::Label " << varName << "Label;\n";
            code << "    std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> " << varName << "Attachment;\n";
            break;
            
        case DraggableWidget::WidgetType::Slider:
            code << "    juce::Slider " << varName << ";\n";
            code << "    juce::Label " << varName << "Label;\n";
            code << "    std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> " << varName << "Attachment;\n";
            break;
            
        case DraggableWidget::WidgetType::Button:
            code << "    juce::TextButton " << varName << ";\n";
            break;
            
        case DraggableWidget::WidgetType::Label:
            code << "    juce::Label " << varName << ";\n";
            break;
            
        default:
            break;
    }
    
    return code;
}

// ============================================================================
// iPlug2 Generator
// ============================================================================
juce::String PluginExporter::generateIPlug2Code(
    const juce::OwnedArray<DraggableWidget>& widgets,
    const juce::String& pluginName)
{
    juce::String code;
    
    code << "// " << pluginName << " - iPlug2 Plugin\n\n";
    code << "#include \"IPlug_include_in_plug_hdr.h\"\n\n";
    
    code << "class " << pluginName << " : public iplug::Plugin\n";
    code << "{\n";
    code << "public:\n";
    code << "    " << pluginName << "(const InstanceInfo& info);\n\n";
    code << "#if IPLUG_DSP\n";
    code << "    void ProcessBlock(sample** inputs, sample** outputs, int nFrames) override;\n";
    code << "#endif\n\n";
    
    code << "private:\n";
    int paramIndex = 0;
    for (auto* widget : widgets)
    {
        if (widget->getWidgetType() == DraggableWidget::WidgetType::Knob ||
            widget->getWidgetType() == DraggableWidget::WidgetType::Slider)
        {
            code << "    // " << widget->getWidgetName() << " - Param " << paramIndex << "\n";
            paramIndex++;
        }
    }
    code << "};\n\n";
    
    // Constructor implementation
    code << pluginName << "::" << pluginName << "(const InstanceInfo& info)\n";
    code << ": Plugin(info, MakeConfig(" << paramIndex << ", 1))\n";
    code << "{\n";
    
    paramIndex = 0;
    for (auto* widget : widgets)
    {
        code << widgetToIPlug2Code(widget, paramIndex);
        if (widget->getWidgetType() == DraggableWidget::WidgetType::Knob ||
            widget->getWidgetType() == DraggableWidget::WidgetType::Slider)
        {
            paramIndex++;
        }
    }
    
    code << "}\n";
    
    return code;
}

juce::String PluginExporter::widgetToIPlug2Code(const DraggableWidget* widget, int index)
{
    juce::String code;
    juce::String varName = widget->getWidgetName().replaceCharacter(' ', '_');
    auto bounds = widget->getBounds();
    
    switch (widget->getWidgetType())
    {
        case DraggableWidget::WidgetType::Knob:
            code << "    GetParam(" << index << ")->InitDouble(\"" << widget->getWidgetName() << "\", 0.5, 0.0, 1.0, 0.01);\n";
            code << "    pGraphics->AttachControl(new IVKnobControl(IRECT(" 
                 << bounds.getX() << ", " << bounds.getY() << ", " 
                 << bounds.getRight() << ", " << bounds.getBottom() << "), " 
                 << index << "));\n";
            break;
            
        case DraggableWidget::WidgetType::Slider:
            code << "    GetParam(" << index << ")->InitDouble(\"" << widget->getWidgetName() << "\", 0.5, 0.0, 1.0, 0.01);\n";
            code << "    pGraphics->AttachControl(new IVSliderControl(IRECT(" 
                 << bounds.getX() << ", " << bounds.getY() << ", " 
                 << bounds.getRight() << ", " << bounds.getBottom() << "), " 
                 << index << "));\n";
            break;
            
        case DraggableWidget::WidgetType::Button:
            code << "    pGraphics->AttachControl(new IVButtonControl(IRECT(" 
                 << bounds.getX() << ", " << bounds.getY() << ", " 
                 << bounds.getRight() << ", " << bounds.getBottom() 
                 << "), [&](IControl* pCaller){ /* action */ }, \"" << widget->getWidgetName() << "\"));\n";
            break;
            
        default:
            break;
    }
    
    return code;
}

// ============================================================================
// DPF (DISTRHO Plugin Framework) Generator
// ============================================================================
juce::String PluginExporter::generateDPFCode(
    const juce::OwnedArray<DraggableWidget>& widgets,
    const juce::String& pluginName)
{
    juce::String code;
    
    code << "// " << pluginName << " - DPF Plugin\n\n";
    code << "#include \"DistrhoPlugin.hpp\"\n\n";
    code << "START_NAMESPACE_DISTRHO\n\n";
    
    code << "class " << pluginName << " : public Plugin\n";
    code << "{\n";
    code << "public:\n";
    code << "    " << pluginName << "();\n\n";
    code << "protected:\n";
    code << "    const char* getLabel() const override { return \"" << pluginName << "\"; }\n";
    code << "    const char* getMaker() const override { return \"Custom Maker\"; }\n";
    code << "    uint32_t getVersion() const override { return d_version(1, 0, 0); }\n\n";
    code << "    void initParameter(uint32_t index, Parameter& parameter) override;\n";
    code << "    float getParameterValue(uint32_t index) const override;\n";
    code << "    void setParameterValue(uint32_t index, float value) override;\n";
    code << "    void run(const float** inputs, float** outputs, uint32_t frames) override;\n\n";
    
    code << "private:\n";
    int paramCount = 0;
    for (auto* widget : widgets)
    {
        if (widget->getWidgetType() == DraggableWidget::WidgetType::Knob ||
            widget->getWidgetType() == DraggableWidget::WidgetType::Slider)
        {
            code << "    float " << widget->getWidgetName().replaceCharacter(' ', '_') << ";\n";
            paramCount++;
        }
    }
    code << "};\n\n";
    
    code << "END_NAMESPACE_DISTRHO\n\n";
    code << "Plugin* createPlugin() { return new " << pluginName << "(); }\n";
    
    return code;
}

juce::String PluginExporter::widgetToDPFCode(const DraggableWidget* widget, int index)
{
    juce::String code;
    juce::String varName = widget->getWidgetName().replaceCharacter(' ', '_');
    
    code << "    case " << index << ":\n";
    code << "        parameter.name = \"" << widget->getWidgetName() << "\";\n";
    code << "        parameter.symbol = \"" << varName << "\";\n";
    code << "        parameter.ranges.min = 0.0f;\n";
    code << "        parameter.ranges.max = 1.0f;\n";
    code << "        parameter.ranges.def = 0.5f;\n";
    code << "        break;\n";
    
    return code;
}

// ============================================================================
// Elements (cycfi) Generator
// ============================================================================
juce::String PluginExporter::generateElementsCode(
    const juce::OwnedArray<DraggableWidget>& widgets,
    const juce::String& pluginName)
{
    juce::String code;
    
    code << "// " << pluginName << " - Elements UI\n\n";
    code << "#include <elements.hpp>\n";
    code << "using namespace cycfi::elements;\n\n";
    
    code << "auto make_" << pluginName.toLowerCase() << "_ui()\n";
    code << "{\n";
    code << "    return vbox(\n";
    
    for (int i = 0; i < widgets.size(); ++i)
    {
        auto* widget = widgets[i];
        code << widgetToElementsCode(widget, i);
        if (i < widgets.size() - 1)
            code << ",\n";
    }
    
    code << "\n    );\n";
    code << "}\n";
    
    return code;
}

juce::String PluginExporter::widgetToElementsCode(const DraggableWidget* widget, int index)
{
    juce::String code;
    juce::String varName = widget->getWidgetName().replaceCharacter(' ', '_');
    
    switch (widget->getWidgetType())
    {
        case DraggableWidget::WidgetType::Knob:
            code << "        dial(\"" << widget->getWidgetName() << "\")";
            break;
            
        case DraggableWidget::WidgetType::Slider:
            code << "        vslider(\"" << widget->getWidgetName() << "\")";
            break;
            
        case DraggableWidget::WidgetType::Button:
            code << "        button(\"" << widget->getWidgetName() << "\")";
            break;
            
        case DraggableWidget::WidgetType::Label:
            code << "        label(\"" << widget->getWidgetName() << "\")";
            break;
            
        default:
            code << "        // Unknown widget type";
            break;
    }
    
    return code;
}

// ============================================================================
// Project Export
// ============================================================================
bool PluginExporter::exportProject(
    FrameworkType framework,
    const juce::File& outputDirectory,
    const juce::OwnedArray<DraggableWidget>& widgets,
    const juce::String& pluginName,
    const juce::String& manufacturer)
{
    if (!outputDirectory.exists())
        outputDirectory.createDirectory();
    
    // Generate main code file
    auto code = generatePluginCode(framework, widgets, pluginName, manufacturer);
    juce::File codeFile = outputDirectory.getChildFile(pluginName + ".cpp");
    
    if (!codeFile.replaceWithText(code))
        return false;
    
    // Generate configuration files
    juce::String config;
    switch (framework)
    {
        case FrameworkType::IPlug2:
            config = generateIPlug2Config(pluginName, manufacturer);
            outputDirectory.getChildFile("config.h").replaceWithText(config);
            break;
            
        case FrameworkType::DPF:
            config = generateDPFMakefile(pluginName);
            outputDirectory.getChildFile("Makefile").replaceWithText(config);
            break;
            
        default:
            config = generateCMakeLists(framework, pluginName);
            outputDirectory.getChildFile("CMakeLists.txt").replaceWithText(config);
            break;
    }
    
    return true;
}

juce::String PluginExporter::generateCMakeLists(FrameworkType framework, const juce::String& pluginName)
{
    juce::String cmake;
    
    cmake << "cmake_minimum_required(VERSION 3.15)\n";
    cmake << "project(" << pluginName << " VERSION 1.0.0)\n\n";
    
    if (framework == FrameworkType::JUCE)
    {
        cmake << "add_subdirectory(JUCE)\n\n";
        cmake << "juce_add_plugin(" << pluginName << "\n";
        cmake << "    PLUGIN_MANUFACTURER_CODE Manu\n";
        cmake << "    PLUGIN_CODE Plgn\n";
        cmake << "    FORMATS VST3 AU Standalone\n";
        cmake << "    PRODUCT_NAME \"" << pluginName << "\")\n\n";
        cmake << "target_sources(" << pluginName << " PRIVATE " << pluginName << ".cpp)\n";
        cmake << "target_link_libraries(" << pluginName << " PRIVATE juce::juce_audio_utils)\n";
    }
    
    return cmake;
}

juce::String PluginExporter::generateIPlug2Config(const juce::String& pluginName, const juce::String& manufacturer)
{
    juce::String config;
    
    config << "#define PLUG_NAME \"" << pluginName << "\"\n";
    config << "#define PLUG_MFR \"" << manufacturer << "\"\n";
    config << "#define PLUG_VERSION_HEX 0x00010000\n";
    config << "#define PLUG_VERSION_STR \"1.0.0\"\n";
    config << "#define PLUG_UNIQUE_ID 'Iplg'\n";
    config << "#define PLUG_MFR_ID 'Manu'\n";
    config << "#define PLUG_URL_STR \"https://example.com\"\n";
    config << "#define PLUG_EMAIL_STR \"info@example.com\"\n";
    config << "#define PLUG_COPYRIGHT_STR \"Copyright 2025\"\n";
    config << "#define PLUG_CLASS_NAME " << pluginName << "\n\n";
    config << "#define BUNDLE_NAME \"" << pluginName << "\"\n";
    config << "#define BUNDLE_MFR \"" << manufacturer << "\"\n";
    config << "#define BUNDLE_DOMAIN \"com\"\n\n";
    config << "#define PLUG_CHANNEL_IO \"1-1 2-2\"\n";
    config << "#define PLUG_LATENCY 0\n";
    config << "#define PLUG_TYPE 0\n";
    config << "#define PLUG_DOES_MIDI_IN 0\n";
    config << "#define PLUG_DOES_MIDI_OUT 0\n";
    config << "#define PLUG_DOES_MPE 0\n";
    config << "#define PLUG_DOES_STATE_CHUNKS 0\n";
    config << "#define PLUG_HAS_UI 1\n";
    config << "#define PLUG_WIDTH 600\n";
    config << "#define PLUG_HEIGHT 400\n";
    config << "#define PLUG_FPS 60\n";
    config << "#define PLUG_SHARED_RESOURCES 0\n";
    config << "#define PLUG_HOST_RESIZE 0\n\n";
    config << "#define AUV2_ENTRY " << pluginName << "_Entry\n";
    config << "#define AUV2_ENTRY_STR \"" << pluginName << "_Entry\"\n";
    config << "#define AUV2_FACTORY " << pluginName << "_Factory\n";
    config << "#define AUV2_VIEW_CLASS " << pluginName << "_View\n";
    config << "#define AUV2_VIEW_CLASS_STR \"" << pluginName << "_View\"\n\n";
    config << "#define AAX_TYPE_IDS 'EFN1', 'EFN2'\n";
    config << "#define AAX_TYPE_IDS_AUDIOSUITE 'EFA1', 'EFA2'\n";
    config << "#define AAX_PLUG_MFR_STR \"Manu\"\n";
    config << "#define AAX_PLUG_NAME_STR \"" << pluginName << "\\nIPEF\"\n";
    config << "#define AAX_PLUG_CATEGORY_STR \"Effect\"\n";
    config << "#define AAX_DOES_AUDIOSUITE 1\n\n";
    config << "#define VST3_SUBCATEGORY \"Fx\"\n";
    config << "#define APP_NUM_CHANNELS 2\n";
    config << "#define APP_N_VECTOR_WAIT 0\n";
    config << "#define APP_MULT 1\n";
    config << "#define APP_COPY_AUV3 0\n";
    config << "#define APP_SIGNAL_VECTOR_SIZE 64\n\n";
    config << "#define ROBOTO_FN \"Roboto-Regular.ttf\"\n";
    
    return config;
}

juce::String PluginExporter::generateDPFMakefile(const juce::String& pluginName)
{
    juce::String makefile;
    
    makefile << "#!/usr/bin/make -f\n";
    makefile << "# Makefile for DPF Plugin\n\n";
    makefile << "include Makefile.base.mk\n\n";
    makefile << "NAME = " << pluginName << "\n\n";
    makefile << "# Files to build\n";
    makefile << "FILES_DSP = " << pluginName << ".cpp\n\n";
    makefile << "# Build targets\n";
    makefile << "all: jack lv2 vst\n\n";
    makefile << "-include Makefile.mk\n";
    
    return makefile;
}
